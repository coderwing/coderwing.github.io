

## AFK原理 & CAP理论

### AFK微服务拆分原则


### 单点问题
```
1、单点故障
2、容量压力
3、并发压力
4、吞吐量压力
```
**解决**

X轴 单点问题可以使用副本备份（全量镜像）来解决，解决读的单点故障压力
![](https://gitee.com/coderwing/blog-images/raw/master/数据库/redis5/redis详解.md/4860478576616.png)

Y轴 容量压力解决：通过将不同类不同业务的数据放在不同的redis节点上
分布式redis节点的方式实现数据存储容量压力和读写压力。
类似于微服务架构设计方案。

Z轴 进一步使用X+Y整体的副本

![](https://gitee.com/coderwing/blog-images/raw/master/数据库/redis5/redis详解.md/5281544894923.png)

---
layout: post
title: Redis AFK和CAP
categories: [Redis, 缓存, 数据库]
description: redis AFK and CAP
keywords: redis, 缓存, ADK, CAP
---

### XYZ设计问题
```
1、一变多一致性：提高了可用性，出现一致性问题
2、强一致性：全部阻塞直到数据一致，破坏可用性，因为多节点同步阻塞会影响并发性能，不实现强一致性，又会出现个节点数据可能不一致的情况。
```
![](https://gitee.com/coderwing/blog-images/raw/master/数据库/redis5/redis详解.md/4019008349765.png)

上图中不一定使用kafka组件，这里的组件解决快速同步数据到Redis节点，并且可以存储数据，保证前方redis节点几遍丢失了数据，也可以同步到后面其他的redis节点。

### CAP理论

#### 概念

**P：分区容忍性**
以实际效果而言，分区相当于对通信的时限要求。系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择；这时候就会出现两种可能性的方向，要么等待数据一致，要么选择一个可用的服务节点而不等待全部一致。

**A：可用性**
在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）

**C：一致性**
在分布式系统中的所有数据备份，在同一时刻是否同样的值，即写操作之后的读操作，必须返回该值。（分为弱一致性、强一致性和最终一致性）

####  集群节点数量
基数个节点：根据投票>n/2原则，奇数个节点的话更容易达到n/2+1的数量，成本更低，并且偶数节点更容易出现故障；
如：3优于4，5优于6